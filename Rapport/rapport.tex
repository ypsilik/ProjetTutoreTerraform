\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\PassOptionsToPackage{hyphens}{url} % url is loaded by hyperref
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother


\date{}

\begin{document}

Explication de: - infrastructure as code OK - provider OK - provisionner
- hébergeur (ovh/ cloudwatt) - vps (instance) OK - mouvance du devops OK
- proof of concept OK - cluster - recette OK - ip Flottante (principe
etc etc)

Partie bénéfice terraform a quoi ca sert concretement / infrastructure
as code Partie comparaison Avant Térraform / mtn avec Terraform

\begin{itemize}
\item
  Réponse au sujet initial (contexte / motivations /
  problématique,réalisations, etc.)
\item
  Inventaire des tâches réalisées, des ressources produites
\item
  Répartition du travail au sein du groupe
\item
  Section Bibliographie (source image et texte Copié)
\item
  intro sur mtn entreprise besoin infra as code / dev ops / cloud
  computing \ldots{} (donc amene utilité Terraforml ss entendu)
\item
  python-nova
\end{itemize}

\section{Introduction}\label{introduction}

\subsection{Le cloud computing}\label{le-cloud-computing}

Le Cloud computing est un concept qui s'oppose à la notion de stockage
local. Pour faire simple, le cloud computing va permettre d'utiliser des
ressources informatiques sans les posséder réellement, de fournir des
services ou des applications accessibles partout depuis internet. Il y a
de nombreux avantages à utiliser un cloud computing. Tout d'abord,
l'utilisateur n'a pas d'infrastructure à gérer, ce qui est parfois plus
simple pour des entreprises, car c'est le fournisseur cloud qui s'occupe
de la maintenance de ses équipements. Il permet donc une réduction des
coûts en n'ayant pas besoin d'investir dans une infrastructure interne,
mais en payant uniquement ce qu'il consomme à son fournisseur de cloud.
Cependant, on a bien entendu des inconvénients comme le fait de savoir
où le prestataire de service stocke nos données (territoire national ou
pas -\textgreater{} problèmes de loi), la sécurité du cloud sur le
stockage, la confidentialité et aussi vis-à-vis des hackers, on doit
donc avoir confiance en le prestataire.

Il existe trois catégories de services pour le cloud computing.

\begin{itemize}
\item
  Le cloud privé : infrastructure pouvant être gérée en interne par
  l'entreprise ou par un prestataire qui se verra confier les tâches
  relatives à l'administration et l'optimisation des performances. Il
  est conçu uniquement pour un seul utilisateur pour répondre aux mieux
  aux besoins. Ce modèle a pour avantage de laisser à l'entreprise le
  contrôle à la fois sur la gestion des services, des données et de
  l'infrastructure. Le fait que ce soit un système fermé permet de mieux
  connaître les paramètres de sécurité, les garanties de service et la
  politique de confidentialité. Cependant, le déploiement de ce type
  d'infrastructure est très coûteux à mettre en place.
\item
  Le cloud public : structure souple et ouverte proposée par des tiers
  spécialisés comme Amazon Web Services, Microsoft Azure, IBM, Google
  Compute Engine ou encore Cloudwatt. Le plus souvent ces services sont
  vendus sur demande, le client va donc être facturé sur ce qu'il
  consomme. L'ensemble de l'infrastructure est géré par le fournisseur
  de service, ce qui permet une utilisation plus souple pour le client.
  Le cloud public s'adapte rapidement aux différents besoins, c'est ce
  qui charme le plus les entreprises (ne pas être limités par le volume
  de données). L'un des inconvénients est l'absence de contrôle sur
  cette solution, que ce soit sur les données, sur la rapidité (beaucoup
  d'utilisateurs serveur mutualisé) pas forcément adapté à nos besoins.
  Si l'entreprise recherche de la confidentialité, le service de cloud
  public n'est pas recommandé. Pour l'aspect économique, ce service va
  permettre une réelle économie, car il n'y a pas de matériel ou
  d'informaticien à gérer, mais plus le client utilisera le service plus
  la facture sera élevée.
\item
  le cloud hybride : est un système mixte qui mélange le cloud privé et
  public. Le client va faire appel à plusieurs clouds indépendants les
  uns des autres, ce qui permet de placer les données sensibles et
  confidentielles dans un cloud privé et les autres dans un cloud
  public. Avec ce type de cloud, on va aussi pouvoir réduire les coûts
  d'exploitation en tirant l'avantage des deux infrastructures, on va
  ainsi dimensionner son cloud privé pour une charge moyenne et le cloud
  public pour répondre aux montées de charge.
\end{itemize}

(TODO : encore du C/c) Les différents modèles de cloud englobent
plusieurs types de services, que l'on peut regrouper en trois parties :
- IaaS - Infrastructure As a Service : le but est d'offrir un service de
bas niveau, le consommateur peut alors choisir le système d'exploitation
et y installer les outils adaptés à ses besoins. Il est possible de
louer dynamiquement des machines virtuelles pour une courte durée. Il
est également possible de louer un ensemble de machines constituant une
infrastructure externe. Les acteurs français du IaaS sont Online.net,
OVH (Kimsufi), \ldots{} - PaaS - Platform As a Service : cette fois-ci,
le système est déjà installé, c'est le fournisseur qui gère le système
et l'infrastructure. Le consommateur profite alors de la plate-forme
pour y installer les applications souhaitées. Un exemple illustrant bien
le PaaS est l'hébergement web, où l'hébergeur fournit une plate-forme
souvent LAMP4, afin d'y héberger des sites web ou des systèmes de
gestion de contenus. - SaaS - Software As a Service : c'est une suite
d'applications proposées aux consommateurs. Ces derniers ne s'occupent
de rien, c'est le fournisseur qui gère l'intégralité de
l'infrastructure, des systèmes et des logiciels. Gmail, Office Web Apps,
Google Apps sont les fournisseurs de SaaS les plus connus.

\subsection{Contexte du projet}\label{contexte-du-projet}

Xilopix (NOTE : url du site) est une start-up basée à Epinal qui
développe un moteur de recherche pensée pour le tactile. Leur
technologie se diffère des autres navigateurs web, car lors d'une
recherche on va avoir une combinaison d'éléments de différentes natures
(textes, images, vidéos, pages web, géolocalisation, sons, etc.) qui
sera possible d'affiner en choisissant à quel info on souhaite avoir
accès. De fait Xilopix va permettre d'améliorer la pertinence des
résultats de recherche tout en offrant une nouvelle expérience
utilisateur à la fois visuelle, tactile et ludique. Xilopix utilise une
infrastructure cloud avec plusieurs hébergeurs (ovh et cloudwatt) tous
sur OpenStack. OpenStack permet de faire du IaaS (le consommateur peut
choisir pour ses machines le système d'exploitation et les différents
outils dont il a besoin), il va monter une infrastructure dans le
domaine du cloud computing. Cependant, Xilopix souhaiterait ne plus être
dépendant d'OpenStack et être libre d'utiliser AWS par exemple. C'est
dans cette optique qu'intervient Terraform.

\subsection{Enjeu et problématique}\label{enjeu-et-probluxe9matique}

L'objectif du projet est de développer un proof of concept sur l'outil
Terraform pour pouvoir démontrer les avantages de cet outil.

\begin{quote}
Un proof of concept est une réalisation expérimentale concrète et
préliminaire, courte ou incomplète, illustrant une certaine méthode ou
idée afin d'en démontrer la faisabilité. (NOTE source wikipédia:
https://fr.wikipedia.org/wiki/Preuve\_de\_concept)
\end{quote}

Pour se faire, nous allons mettre en place un cluster de quatres
machines virtuelles ainsi qu'un réseau, un sous-réseau et un routeur
pour recréer une infrastructure minimale fonctionnelle avec l'outil
Terraform. Xilopix ayant une infrastructure utilisant OpenStack, nous
avons créer des configurations fonctionnant pour OpenStack.

A partir de ces études, Xilopix pourra choisir d'utiliser ou non cet
outil.

La finalité du projet est d'obtenir une création rapide et demandant un
minimum d'intervention humaine pour déployer plusieurs machines aussi
bien sous OpenStack, sous AWS ou tout autre provider. Terraform va donc
nous permettre de réduire les dépendances entre ces outils et les
infrastructures qui les utilisent tout en facilitant la mise en place de
machines.

\subsection{Quelques mots sur
Openstack}\label{quelques-mots-sur-openstack}

OpenStack est un ensemble de logiciels/modules open source permettant de
déployer des infrastructures de cloud computing. La technologie possède
une architecture modulaire composée de plusieurs projets (Nova, Swift,
Glance\ldots{}) qui permettent de contrôler les différentes ressources
des machines virtuelles telles que la puissance de calcul, le stockage
ou encore le réseau inhérents au centre de données sollicité.

\subsection{Quelques mots sur
Terraform}\label{quelques-mots-sur-terraform}

Terraform est une solution pour la construction, la modification et le
versionning d'infrastructure de manière sûre et efficace. Développé
depuis 2013 par HashiCorp, c'est un outil en pleine expansion. Il permet
de gérer plusieurs fournisseurs de services existant ainsi que des
solutions développées en interne. Avec cette technologie, il est
possible d'administrer des composants de bas niveau comme les IaaS, le
stockage et la mise à niveau, ainsi que des composants haut niveau comme
les entrées DNS et les fonctionnalités SaaS.

\section{Terraform}\label{terraform}

\subsection{Présenation (Schéma de ou se place dans prod -dans meme
style celui du book crack mais avec ansible en plus (voir xml de
draw.io))}\label{pruxe9senation-schuxe9ma-de-ou-se-place-dans-prod--dans-meme-style-celui-du-book-crack-mais-avec-ansible-en-plus-voir-xml-de-draw.io}

Terraform est un outil développé en Go qui permet la gestion
d'infrastructure à l'aide de recettes. L'objectif de ce logiciel est de
permettre une configuration centralisée, rapide et efficace d'une
infrastructure.

Terraform fonctionne avec des fichiers texte pour configurer les futures
infrastructures. Ces fichiers texte appelé \og recette \fg servent à
décrire l'architecture des providers tel qu'Openstack ou AWS. La
configuration se fait dans un fichier \og main.tf \fg qui est écrit en
HCL(NOTE: HashiCorp Configuration Language). La configuration peut aussi
être générée automatiquement par machine avec le format JSON(NOTE).
L'extension du fichier sera alors \og main.tf.json \fg.

Un provider est un service pour le cloud computing, généralement un
IaaS.

Terraform génère un plan d'exécution se basant sur les recettes et
décrivant les étapes qu'il va effectuer. Puis exécute le plan
précédemment défini pour mettre en place l'infrastructure. Terraform
détecte les changements effectué dans les fichiers et créé des nouveaux
plans d'exécution conformément à ses changements.

Terraform permet de gérer les composants de bas niveau comme les IaaS,
le stockage et la mise à niveau, ainsi que des composants hauts niveaux
comme les entrées DNS et les fonctionnalités SaaS.

\subsection{Caractéristiques}\label{caractuxe9ristiques}

\begin{itemize}
\item
  ** Insfrastructure as code : ** L'infrastructure est décrite en
  utilisant une syntaxe de configuration de haut niveau (HCL). Cela
  permet à un data center d'être versionné et traité comme tout autre
  code.
\item
  ** Plan d'exécution : ** Terraform a une étape de \og planification
  \fg qui génère un plan d'exécution. Le plan d'exécution montre les
  actions que Terraform effectuera lorsqu'il sera lancé. Cela permet
  d'augmenter la sécurité en évitant d'avoir des surprises lorsque
  Terraform manipule l'infrastructure.
\item
  ** Graphique des ressources : ** Terraform construit un graphique de
  toutes les ressources des infrastructures, et parallélise la création
  et la modification de toutes ces ressources non-dépendantes. Grâce à
  cela, Terraform construit l'infrastructure aussi efficacement que
  possible, et les utilisateurs peuvent avoir un aperçu des dépendances
  de leur infrastructure.
\item
  ** Automatisation des changements : ** Des ensembles complexes de
  changements peuvent être appliqués à une infrastructure avec une
  interaction humaine minimale. Pour se faire Terraform se base sur le
  plan d'exécution et le graphique de ressources mentionnés
  précédemment, évitant ainsi des erreurs humaines possibles.
\end{itemize}

\subsection{Quelques cas d'utilisations (selon la
doc)}\label{quelques-cas-dutilisations-selon-la-doc}

\subsubsection{Self-service Cluster}\label{self-service-cluster}

Dans de grandes organisations, il devient plus attrayant de créer une
infrastructure \og self-service \fg, permettant aux équipes de gérer
leur propre infrastructure à l'aide de l'outillage fourni par l'équipe
centrale d'exploitation.

À l'aide de Terraform, la connaissance de la construction de
l'infrastructure et de l'échelle d'un service peut être codifiée dans
une configuration. La configuration de Terraform peut être partagée au
sein d'une organisation permettant aux équipes d'utiliser Terraform
comme un outil pour gérer leurs services sans connaître la
configuration.

\subsubsection{Démos de logiciels}\label{duxe9mos-de-logiciels}

A l'instar de Vagrant qui permet la création d'environnement virtualisé,
les éditeurs de logiciels peuvent fournir une configuration Terraform
pour créer et démarrer une infrastructure de démonstration. Ceci permet
aux utilisateurs finaux de mettre en place rapidement un environnement
de test sur leur propre infrastructure.

\subsubsection{Multi
Cloud-Déploiement}\label{multi-cloud-duxe9ploiement}

Il est souvent attrayant de répandre l'infrastructure sur plusieurs
cloud pour augmenter la tolérance aux pannes. En utilisant une seule
région ou un seul fournisseur cloud , la tolérance aux pannes est
limitée par la disponibilité de ce fournisseur. Avoir un déploiement
multi-cloud permet une meilleure récupération de la perte d'une région
ou tout le fournisseur.

Terraform permet la configuration de plusieurs providers en une seule
configuration. Cela simplifie la gestion et l'orchestration des
providers, en aidant la création d'infrastructures multi-cloud.

\subsection{Syntaxe utilisé}\label{syntaxe-utilisuxe9}

Les configurations de Terraform sont écrites en HashiCorp Configuration
Language (HCL). Ce langage se veut facile à écrire et à lire. L'écriture
des configurations peut aussi se faire en JSON.

\subsubsection{Les bases du langage}\label{les-bases-du-langage}

\emph{Commentaires} - \# sur une seule ligne - /* mon commentaires sur
plusieurs lignes */

\emph{Affectation des valeurs}

\begin{verbatim}
key = value # la valeur peut être une chaîne, un nombre ou un booléen
\end{verbatim}

\emph{Chaînes multilignes} : On utilise
\texttt{\textless{}\textless{}\ -\ EOF} et \texttt{EOF} pour créer des
chaînes multilignes ce qui permet principalement d'intégrer des scripts
dans la configuration.

Il existe également de nombreuses fonctions utilisables avec HCL comme
par exemple la fonction format(format, args, \ldots{}) qui va permettre
de formater une chaîne selon le format que l'on donne.

\subsection{Fonctionnement}\label{fonctionnement}

Terraform étant développé en Go, il n'a pas besoin d'être installé. Il
suffit de télécharger une archive .zip et de l'extraire. Il est ensuite
possible d'utiliser les commandes associées à Terraform avec
\texttt{./terraform\ ...}. Pour faciliter l'utilisation des commandes,
il est recommandé de copier le fichier dans \emph{/usr/local/} et
d'ajouter ensuite le chemin menant jusqu'au fichier en question dans le
PATH \texttt{PATH=/usr/local/...:\$PATH}.

Terraform peut être composé de plusieurs fichiers de configuration pour
une infrastructure. Dans ce cas, les fichiers sont lus par ordre
alphabétique, mais la priorité reste au fichier \emph{main.tf}.

\subsubsection{\texorpdfstring{Bloc
\textbf{\texttt{provider}}}{Bloc provider}}\label{bloc-provider}

C'est la partie configuration du provider avec principalement les accès
pour la connexion à celui-ci. Terraform peut contenir plusieurs blocs
provider. Ce bloc gère le cycle de vie des ressources (create, read,
update, delete).

\begin{verbatim}
provider "openstack" {
    user_name  = "admin"
    tenant_name = "admin"
    password  = "pwd"
    auth_url  = "http://myauthurl:5000/v2.0"
}
\end{verbatim}

Cloudwatt offre la génération d'un fichier .sh avec la totalité des
identifiants est accès pour Openstack. Pour la connection, nous avons pu
ommettre le bloc provider, Terraform se charge de récuperer les
variables environnementales correspondant aux paramètres dont il a
besoin pour retrouver le provider.

\subsubsection{\texorpdfstring{Bloc
\textbf{\texttt{resources}}}{Bloc resources}}\label{bloc-resources}

Partie permettant la gestion des ressources (composants physiques et
logiciels) qui existent dans l'infrastructure. Le nom d'une ressource se
compose du nom du provider puis du nom de la ressource en un bloc et
enfin un nom pour cette ressource terraform qui sera utilisé uniquement
par terraform.

\begin{verbatim}
resource "openstack_compute_instance_v2" "nomTerraform" {
}
\end{verbatim}

\subsubsection{Variables}\label{variables}

Les variables peuvent être enregistrées dans un fichier \og variables.tf
\fg ou \og .tfvars \fg. Pour appliquer des variables enregistrées sous
cette dernière extension, il faut lancer la commande suivante
\texttt{terraform\ apply\ -var-file=truc.tfvars}. Les variable sont
généralement utilisé dans les fichiers sous la forme suivante
\texttt{\$\{var.nomVar\}}.

\subsubsection{Modules (on a pas vraiment exploré ca, on le met
?)}\label{modules-on-a-pas-vraiment-exploruxe9-ca-on-le-met}

Terraform possède des modules autonome vis-à-vis des configurations
Terraform. Ces modules peuvent être installés par Terraform. Un module
peut être un morceau de code Terraform ayant une fonction qui sera
ensuite appelé.

\begin{verbatim}
module "Name" {
    source = "github.../dossier"
}
\end{verbatim}

\subsubsection{Les commandes}\label{les-commandes}

\begin{itemize}
\tightlist
\item
  \texttt{terraform\ plan} -- génère un plan d'action de la
  configuration. Le plan inclu toutes les actions faites et montre les
  modifications que va effectuer Terraform.
\item
  \texttt{terraform\ plan\ -destroy\ -out=destroy.tf} -- génère un plan
  d'action qui à pour objectif de détruire tous le projet défini pas les
  fichiers de configuration. Le résultat est enregistré dans un fichier
  pour ensuite être appliqué avec \texttt{terraform\ apply\ destroy.tf}.
\item
  \texttt{terraform\ destroy} -- détruit les configurations terraform
  qui ont été lancées depuis la même machine (équivalent à la technique
  du dessus).
\item
  \texttt{terraform\ apply} -- applique le plan
\item
  \texttt{terraform\ graph} -- permet visualisation du plan
\item
  \texttt{terraform\ show} -- montre les infra en place
\end{itemize}

\subsection{Configurations
effectuées}\label{configurations-effectuuxe9es}

\subsubsection{Keypair}\label{keypair}

Une des premières configurations effectuées fut l'ajout de clef ssh pour
le projet. Cet ajout avait pour objectif de nous permettre de nous
connecter en ssh avec les instances créées.

\begin{verbatim}
resource "openstack_compute_keypair_v2" "my_keypair" {
  name = "my_keypair"
  public_key = "${var.keypair}"
}
\end{verbatim}

Terraform prend en paramètre pour cette resource un nom et la clef
publique à ajouter. Cette clef ssh est requise lors de la création
d'instance. En effet celles-ci prennent en paramètre une keypair -
\texttt{key\_pair\ =\ "\$\{openstack\_compute\_keypair\_v2.my\_keypair.name\}"}
- pour permettre la connection ssh à l'instance en question. Cependant
une seule keypair peut être intégrée dans la ressource \emph{instance}.
Pour avoir tous accès en ssh aux instances, nous nous sommes paratagé la
clef privé créée spécialement pour le projet et n'ayant pas de
passphrase pour permettre à ansible de se connecter ensuite.

\subsubsection{Instances}\label{instances}

Les instances sont la plus grande partie de la configuration, elles
correspondent aux réseaux privés virtuels (vps) qui vont être créées.

\begin{verbatim}
resource "openstack_compute_instance_v2" "vps" {
  count = 3
  name = "vps-test-${(count.index)+1}"
  image_id = "185e1975-c9c5-4358-909e-5e329808902e"
  flavor_id = "16"
  key_pair = "${openstack_compute_keypair_v2.my_keypair.name}"
  security_groups = ["${openstack_compute_secgroup_v2.terraform.id}"]
  floating_ip = "${element(openstack_compute_floatingip_v2.terraform.*.address, count.index+1)}"

  network {
    name = "${openstack_networking_network_v2.network_1.name}"
    fixed_ip_v4 = "192.168.0.1${(count.index)+1}"
  }
}
\end{verbatim}

Une instance peut être créée dans une configuration unique, mais il est
aussi possible d'en générer plusieurs automatiquement avec une seule
ressource associée grâce au paramètre \texttt{count}. La création des
insantances se fait donc en partant de zéro. Avec \texttt{count.index}
nous pouvons récuperer l'index actuel de la boucle générée par
tarraform. Chaque instance est ratachée à un ou plusieurs réseaus selon
les besoins. Pour notre proof of concept, nous avons utilisé un seul
réseau. Pour connecter les instances au réseau, il faut écrire un bloc
\emph{network} comme ci-dessus.

\subsubsection{Security group}\label{security-group}

Le security group permet d'autoriser les transmissions sur certain port.
Un security group fonctionne sur le même principe qu'un firewall. Il est
conposé de règles \emph{rule}. Une règle est définit pour un port. Nous
avons crés un security group nommé \og terraform \fg composé d'une seule
règle permettant la connection ssh (port 22).

\begin{verbatim}
resource "openstack_compute_secgroup_v2" "terraform" {
  name        = "terraform"
  description = "security group"
  rule {
    from_port   = 22
    to_port     = 22
    ip_protocol = "tcp"
    cidr        = "0.0.0.0/0"
  }
}
\end{verbatim}

\subsubsection{Ip flotantes}\label{ip-flotantes}

Les ip flotantes permettent aux instances d'avoir une ip publique.
Permettant ainsi de pouvoir accéder en ssh aux instances. Terraform
offre la posibilité de générer automatiquement les adresses ip en les
piochant dans un pool public d'adresses. Cependant l'utiisation
d'ansible requière la connaissance des adresses ip flottantes attribuée
aux machines. Pour ce faire plusieurs solutions s'offraient à nous. - La
première est l'importation des adresses ip avec
\texttt{terraform\ import}. Cependant Terraform ne permet pas la
création de boucle, seule la variable \emph{count} est utilisable. Le
changement de nom de la ressource importée est impossible avec ce
système de boucle. L'importation avec terraform fonctionne de la manière
suivante : La ressource est importé avec la commande, mais pour être
utilisable elle doit avoir une ressource créée dans le fichier .tf.
L'importation d'une multitude d'adresses ip entrainaient la création du
même nombre de ressources le tout créé à la main. La tâche devenaient
vite fastidieuse. - La seconde solution est la création d'une liste
contenant les adresses ip floatantes créées depuis l'interface web de
l'hébergeur. L'appel de l'adresse se fait depuis la ressource instance
de terraform qui vas récuperer une adresse dans la liste.

\begin{verbatim}
#Ip flotantes
variable "id_ip_flottante" {
    default = ["84.39.49.19","84.39.46.157","84.39.44.165","84.39.41.206"]
}

resource "openstack_compute_instance_v2" "vps" {
    floating_ip = "${var.id_ip_flottante[(count.index)+1]}"
}
\end{verbatim}

Nous avons donc choisit cette dernière pour mettre en place le système
d'ip flotantes dans notre infrastructure terraform.

\subsubsection{Réseau, sous-réseau et
routeur}\label{ruxe9seau-sous-ruxe9seau-et-routeur}

Terraform permettant de créer toute une infrastructure, nous nous sommes
aussi penchés sur la création du réseau, de ses sous-réseaux et du
routeur nous permettant un accès au monde extérieur.

\paragraph{Réseau et sous-réseau}\label{ruxe9seau-et-sous-ruxe9seau}

Pour être utilisable, les instances doivent être connectées à un réseau.
Terraform offre la possibilité de crée rapidement et facilement un
réseau ainsi que les sous-réseaux et port utile à celui-ci. Les
instances sont donc configuré pour être intégrées à ce réseau et obtenir
une adresse ip dans ce dernier.

\begin{verbatim}
resource "openstack_networking_network_v2" "network_1" {
  name = "resTerraform"
  admin_state_up = "true"
}

# Sous-réseau
resource "openstack_networking_subnet_v2" "subnet_2" {
  name = "SousRes_2"
  network_id = "${openstack_networking_network_v2.network_1.id}"
  cidr = "192.168.0.0/24"
  ip_version = 4 
}

#Port du sous-réseau
resource "openstack_networking_port_v2" "port_1" {
  name = "port_1"
  network_id = "${openstack_networking_network_v2.network_1.id}"
  admin_state_up = "true"
}
\end{verbatim}

\paragraph{Routeur}\label{routeur}

Pour que l'infrastructure créée soit opérationelle, il faut lui
autoriser un accès à l'extérieur du réseau. Pour se faire nous passons
par un routeur qui est lui même composé d'une interface le relinant à un
des réseau crée précedement.

\begin{verbatim}
resource "openstack_networking_router_v2" "router_1" {
  name = "routerTerraform"
  admin_state_up = "true"
  external_gateway = "6ea98324-0f14-49f6-97c0-885d1b8dc517"
}
\end{verbatim}

\section{Provisionnement}\label{provisionnement}

Terraform permet aussi le provisionnement de ses instances avec
différents provisionners comme chef, puppet ou encore ansible. Cependant
Terraform n'offre un service que pour Chef mais permet d'éxécuter
différentes commande automatiquement depuis la machine lancant
\texttt{terraform\ apply} avec le provisionner \texttt{local\_exec} ou
depuis la machine générée avec Terraform grâce au provisionner
\texttt{remote\_exec}. Celui-ci se compléte avec le bloc
\texttt{connection} effectuant une connexion ssh avec les identifiants
désiré. Ces dernières se mettant dans les instances. Les ressources de
type \texttt{null-ressource} permettent d'executer des commandes après
la création des certaines ressources. Grâce à cela, il est possible de
lancer ansible automatiquement à la fin de la création des vps.

\section{Ansible}\label{ansible}

\subsection{Présentation}\label{pruxe9sentation}

\subsection{Utilisation, Fonctionnement,
syntaxe}\label{utilisation-fonctionnement-syntaxe}

\subsection{Intégration à
Terraform}\label{intuxe9gration-uxe0-terraform}

\subsection{Configuration effectuée (pk on l'a fait, surtout expliqué
pour les clef
ssh)}\label{configuration-effectuuxe9e-pk-on-la-fait-surtout-expliquuxe9-pour-les-clef-ssh}

\section{Conclusion}\label{conclusion}

\subsection{Ce qu'on a fait}\label{ce-quon-a-fait}

\subsection{Utilité de Terraform, easy to use
?}\label{utilituxe9-de-terraform-easy-to-use}

\end{document}
